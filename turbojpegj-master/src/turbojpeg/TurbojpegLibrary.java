package turbojpeg;

import java.util.Collections;
import java.util.Iterator;

import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.ann.CLong;
import org.bridj.ann.Library;
import org.bridj.ann.Runtime;

/**
 * Wrapper for library <b>turbojpeg</b><br>
 * This file was autogenerated by <a
 * href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a
 * href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few
 * opensource projects.</a>.<br>
 * For help, please visit <a
 * href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a
 * href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("turbojpeg")
@Runtime(CRuntime.class)
public class TurbojpegLibrary
{
	static
	{
		BridJ.register();
	}

	/**
	 * Chrominance subsampling options.<br>
	 * When an image is converted from the RGB to the YCbCr colorspace as part of<br>
	 * the JPEG compression process, some of the Cb and Cr (chrominance)
	 * components<br>
	 * can be discarded or averaged together to produce a smaller image with
	 * little<br>
	 * perceptible loss of image clarity (the human eye is more sensitive to small<br>
	 * changes in brightness than small changes in color.) This is called<br>
	 * "chrominance subsampling".<br>
	 * enum values<br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:63</i>
	 */
	public enum TJSAMP implements IntValuedEnum<TJSAMP>
	{
		/**
		 * 4:4:4 chrominance subsampling (no chrominance subsampling). The JPEG or<br>
		 * YUV image will contain one chrominance component for every pixel in the<br>
		 * source image.
		 */
		TJSAMP_444(0),
		/**
		 * 4:2:2 chrominance subsampling. The JPEG or YUV image will contain one<br>
		 * chrominance component for every 2x1 block of pixels in the source image.
		 */
		TJSAMP_422(1),
		/**
		 * 4:2:0 chrominance subsampling. The JPEG or YUV image will contain one<br>
		 * chrominance component for every 2x2 block of pixels in the source image.
		 */
		TJSAMP_420(2),
		// / Grayscale. The JPEG or YUV image will contain no chrominance
		// components.
		TJSAMP_GRAY(3),
		/**
		 * 4:4:0 chrominance subsampling. The JPEG or YUV image will contain one<br>
		 * chrominance component for every 1x2 block of pixels in the source image.
		 */
		TJSAMP_440(4);
		TJSAMP(final long value)
		{
			this.value = value;
		}

		public final long value;

		@Override
		public long value()
		{
			return this.value;
		}

		@Override
		public Iterator<TJSAMP> iterator()
		{
			return Collections.singleton(this).iterator();
		}

		public static IntValuedEnum<TJSAMP> fromValue(final int value)
		{
			return FlagSet.fromValue(value, values());
		}
	};

	/**
	 * Pixel formats<br>
	 * enum values<br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:121</i>
	 */
	public enum TJPF implements IntValuedEnum<TJPF>
	{
		/**
		 * RGB pixel format. The red, green, and blue components in the image are<br>
		 * stored in 3-byte pixels in the order R, G, B from lowest to highest byte<br>
		 * address within each pixel.
		 */
		TJPF_RGB(0),
		/**
		 * BGR pixel format. The red, green, and blue components in the image are<br>
		 * stored in 3-byte pixels in the order B, G, R from lowest to highest byte<br>
		 * address within each pixel.
		 */
		TJPF_BGR(1),
		/**
		 * RGBX pixel format. The red, green, and blue components in the image are<br>
		 * stored in 4-byte pixels in the order R, G, B from lowest to highest byte<br>
		 * address within each pixel. The X component is ignored when compressing<br>
		 * and undefined when decompressing.
		 */
		TJPF_RGBX(2),
		/**
		 * BGRX pixel format. The red, green, and blue components in the image are<br>
		 * stored in 4-byte pixels in the order B, G, R from lowest to highest byte<br>
		 * address within each pixel. The X component is ignored when compressing<br>
		 * and undefined when decompressing.
		 */
		TJPF_BGRX(3),
		/**
		 * XBGR pixel format. The red, green, and blue components in the image are<br>
		 * stored in 4-byte pixels in the order R, G, B from highest to lowest byte<br>
		 * address within each pixel. The X component is ignored when compressing<br>
		 * and undefined when decompressing.
		 */
		TJPF_XBGR(4),
		/**
		 * XRGB pixel format. The red, green, and blue components in the image are<br>
		 * stored in 4-byte pixels in the order B, G, R from highest to lowest byte<br>
		 * address within each pixel. The X component is ignored when compressing<br>
		 * and undefined when decompressing.
		 */
		TJPF_XRGB(5),
		/**
		 * Grayscale pixel format. Each 1-byte pixel represents a luminance<br>
		 * (brightness) level from 0 to 255.
		 */
		TJPF_GRAY(6),
		/**
		 * RGBA pixel format. This is the same as @ref TJPF_RGBX, except that when<br>
		 * decompressing, the X component is guaranteed to be 0xFF, which can be<br>
		 * interpreted as an opaque alpha channel.
		 */
		TJPF_RGBA(7),
		/**
		 * BGRA pixel format. This is the same as @ref TJPF_BGRX, except that when<br>
		 * decompressing, the X component is guaranteed to be 0xFF, which can be<br>
		 * interpreted as an opaque alpha channel.
		 */
		TJPF_BGRA(8),
		/**
		 * ABGR pixel format. This is the same as @ref TJPF_XBGR, except that when<br>
		 * decompressing, the X component is guaranteed to be 0xFF, which can be<br>
		 * interpreted as an opaque alpha channel.
		 */
		TJPF_ABGR(9),
		/**
		 * ARGB pixel format. This is the same as @ref TJPF_XRGB, except that when<br>
		 * decompressing, the X component is guaranteed to be 0xFF, which can be<br>
		 * interpreted as an opaque alpha channel.
		 */
		TJPF_ARGB(10);
		TJPF(final long value)
		{
			this.value = value;
		}

		public final long value;

		@Override
		public long value()
		{
			return this.value;
		}

		@Override
		public Iterator<TJPF> iterator()
		{
			return Collections.singleton(this).iterator();
		}

		public static IntValuedEnum<TJPF> fromValue(final int value)
		{
			return FlagSet.fromValue(value, values());
		}
	};

	/**
	 * Transform operations for #tjTransform()<br>
	 * enum values<br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:291</i>
	 */
	public enum TJXOP implements IntValuedEnum<TJXOP>
	{
		// / Do not transform the position of the image pixels
		TJXOP_NONE(0),
		/**
		 * Flip (mirror) image horizontally. This transform is imperfect if there<br>
		 * are any partial MCU blocks on the right edge (see #TJXOPT_PERFECT.)
		 */
		TJXOP_HFLIP(1),
		/**
		 * Flip (mirror) image vertically. This transform is imperfect if there are<br>
		 * any partial MCU blocks on the bottom edge (see #TJXOPT_PERFECT.)
		 */
		TJXOP_VFLIP(2),
		/**
		 * Transpose image (flip/mirror along upper left to lower right axis.) This<br>
		 * transform is always perfect.
		 */
		TJXOP_TRANSPOSE(3),
		/**
		 * Transverse transpose image (flip/mirror along upper right to lower left<br>
		 * axis.) This transform is imperfect if there are any partial MCU blocks in<br>
		 * the image (see #TJXOPT_PERFECT.)
		 */
		TJXOP_TRANSVERSE(4),
		/**
		 * Rotate image clockwise by 90 degrees. This transform is imperfect if<br>
		 * there are any partial MCU blocks on the bottom edge (see<br>
		 * #TJXOPT_PERFECT.)
		 */
		TJXOP_ROT90(5),
		/**
		 * Rotate image 180 degrees. This transform is imperfect if there are any<br>
		 * partial MCU blocks in the image (see #TJXOPT_PERFECT.)
		 */
		TJXOP_ROT180(6),
		/**
		 * Rotate image counter-clockwise by 90 degrees. This transform is imperfect<br>
		 * if there are any partial MCU blocks on the right edge (see<br>
		 * #TJXOPT_PERFECT.)
		 */
		TJXOP_ROT270(7);
		TJXOP(final long value)
		{
			this.value = value;
		}

		public final long value;

		@Override
		public long value()
		{
			return this.value;
		}

		@Override
		public Iterator<TJXOP> iterator()
		{
			return Collections.singleton(this).iterator();
		}

		public static IntValuedEnum<TJXOP> fromValue(final int value)
		{
			return FlagSet.fromValue(value, values());
		}
	};

	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJXOPT_NOOUTPUT = 16;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJXOPT_TRIM = 2;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJFLAG_FORCEMMX = 8;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJFLAG_NOREALLOC = 1024;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJFLAG_FASTUPSAMPLE = 256;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJFLAG_FORCESSE = 16;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJXOPT_PERFECT = 1;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int NUMSUBOPT = 5;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJ_NUMSAMP = 5;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJ_BGR = 1;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJ_ALPHAFIRST = 64;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJ_FORCESSE3 = 128;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJXOPT_CROP = 4;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJ_NUMPF = 11;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJFLAG_ACCURATEDCT = 4096;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJ_FORCESSE2 = 32;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJ_BOTTOMUP = 2;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJFLAG_FORCESSE3 = 128;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJFLAG_BOTTOMUP = 2;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJ_FASTUPSAMPLE = 256;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJFLAG_FORCESSE2 = 32;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJ_FORCESSE = 16;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJXOPT_GRAY = 8;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJFLAG_FASTDCT = 2048;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJ_YUV = 512;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJ_NUMXOP = 8;
	// / <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h</i>
	public static final int TJ_FORCEMMX = 8;

	/**
	 * Create a TurboJPEG compressor instance.<br>
	 * * @return a handle to the newly-created instance, or NULL if an error<br>
	 * occurred (see #tjGetErrorStr().)<br>
	 * Original signature : <code>tjhandle tjInitCompress()</code><br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:505</i>
	 */
	public static native Pointer<?> tjInitCompress();

	/**
	 * Compress an RGB or grayscale image into a JPEG image.<br>
	 * * @param handle a handle to a TurboJPEG compressor or transformer instance<br>
	 * 
	 * @param srcBuf
	 *          pointer to an image buffer containing RGB or grayscale pixels<br>
	 *          to be compressed<br>
	 * @param width
	 *          width (in pixels) of the source image<br>
	 * @param pitch
	 *          bytes per line of the source image. Normally, this should be<br>
	 *          <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is
	 *          unpadded,<br>
	 *          or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line
	 *          of<br>
	 *          the image is padded to the nearest 32-bit boundary, as is the case<br>
	 *          for Windows bitmaps. You can also be clever and use this parameter<br>
	 *          to skip lines, etc. Setting this parameter to 0 is the equivalent
	 *          of<br>
	 *          setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.<br>
	 * @param height
	 *          height (in pixels) of the source image<br>
	 * @param pixelFormat
	 *          pixel format of the source image (see @ref TJPF<br>
	 *          "Pixel formats".)<br>
	 * @param jpegBuf
	 *          address of a pointer to an image buffer that will receive the<br>
	 *          JPEG image. TurboJPEG has the ability to reallocate the JPEG
	 *          buffer<br>
	 *          to accommodate the size of the JPEG image. Thus, you can choose
	 *          to:<br>
	 *          -# pre-allocate the JPEG buffer with an arbitrary size using<br>
	 *          #tjAlloc() and let TurboJPEG grow the buffer as needed,<br>
	 *          -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the<br>
	 *          buffer for you, or<br>
	 *          -# pre-allocate the buffer to a "worst case" size determined by<br>
	 *          calling #tjBufSize(). This should ensure that the buffer never has<br>
	 *          to be re-allocated (setting #TJFLAG_NOREALLOC guarantees this.)<br>
	 *          .<br>
	 *          If you choose option 1, <tt>*jpegSize</tt> should be set to the<br>
	 *          size of your pre-allocated buffer. In any case, unless you have<br>
	 *          set #TJFLAG_NOREALLOC, you should always check <tt>*jpegBuf</tt>
	 *          upon<br>
	 *          return from this function, as it may have changed.<br>
	 * @param jpegSize
	 *          pointer to an unsigned long variable that holds the size of<br>
	 *          the JPEG image buffer. If <tt>*jpegBuf</tt> points to a<br>
	 *          pre-allocated buffer, then <tt>*jpegSize</tt> should be set to the<br>
	 *          size of the buffer. Upon return, <tt>*jpegSize</tt> will contain
	 *          the<br>
	 *          size of the JPEG image (in bytes.)<br>
	 * @param jpegSubsamp
	 *          the level of chrominance subsampling to be used when<br>
	 *          generating the JPEG image (see @ref TJSAMP<br>
	 *          "Chrominance subsampling options".)<br>
	 * @param jpegQual
	 *          the image quality of the generated JPEG image (1 = worst,<br>
	 *          100 = best)<br>
	 * @param flags
	 *          the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
	 *          "flags".<br>
	 *          * @return 0 if successful, or -1 if an error occurred (see
	 *          #tjGetErrorStr().)<br>
	 *          Original signature :
	 *          <code>int tjCompress2(tjhandle, unsigned char*, int, int, int, int, unsigned char**, unsigned long*, int, int, int)</code>
	 * <br>
	 *          <i>native declaration :
	 *          libjpeg-turbo\win64\include\turbojpeg.h:555</i>
	 */
	public static native int tjCompress2(	Pointer<?> handle,
																				Pointer<Byte> srcBuf,
																				int width,
																				int pitch,
																				int height,
																				int pixelFormat,
																				Pointer<Pointer<Byte>> jpegBuf,
																				Pointer<org.bridj.CLong> jpegSize,
																				int jpegSubsamp,
																				int jpegQual,
																				int flags);

	/**
	 * The maximum size of the buffer (in bytes) required to hold a JPEG image
	 * with<br>
	 * the given parameters. The number of bytes returned by this function is<br>
	 * larger than the size of the uncompressed source image. The reason for this<br>
	 * is that the JPEG format uses 16-bit coefficients, and it is thus possible<br>
	 * for a very high-quality JPEG image with very high frequency content to<br>
	 * expand rather than compress when converted to the JPEG format. Such images<br>
	 * represent a very rare corner case, but since there is no way to predict the<br>
	 * size of a JPEG image prior to compression, the corner case has to be<br>
	 * handled.<br>
	 * * @param width width of the image (in pixels)<br>
	 * 
	 * @param height
	 *          height of the image (in pixels)<br>
	 * @param jpegSubsamp
	 *          the level of chrominance subsampling to be used when<br>
	 *          generating the JPEG image (see @ref TJSAMP<br>
	 *          "Chrominance subsampling options".)<br>
	 *          * @return the maximum size of the buffer (in bytes) required to
	 *          hold the<br>
	 *          image, or -1 if the arguments are out of bounds.<br>
	 *          Original signature : <code>long tjBufSize(int, int, int)</code><br>
	 *          <i>native declaration :
	 *          libjpeg-turbo\win64\include\turbojpeg.h:580</i>
	 */
	@CLong
	public static native long tjBufSize(int width,
																			int height,
																			int jpegSubsamp);

	/**
	 * The size of the buffer (in bytes) required to hold a YUV planar image with<br>
	 * the given parameters.<br>
	 * * @param width width of the image (in pixels)<br>
	 * 
	 * @param height
	 *          height of the image (in pixels)<br>
	 * @param subsamp
	 *          level of chrominance subsampling in the image (see<br>
	 * @ref TJSAMP "Chrominance subsampling options".)<br>
	 *      * @return the size of the buffer (in bytes) required to hold the
	 *      image, or<br>
	 *      -1 if the arguments are out of bounds.<br>
	 *      Original signature : <code>long tjBufSizeYUV(int, int, int)</code><br>
	 *      <i>native declaration :
	 *      libjpeg-turbo\win64\include\turbojpeg.h:596</i>
	 */
	@CLong
	public static native long tjBufSizeYUV(	int width,
																					int height,
																					int subsamp);

	/**
	 * Encode an RGB or grayscale image into a YUV planar image. This function<br>
	 * uses the accelerated color conversion routines in TurboJPEG's underlying<br>
	 * codec to produce a planar YUV image that is suitable for X Video.<br>
	 * Specifically, if the chrominance components are subsampled along the<br>
	 * horizontal dimension, then the width of the luminance plane is padded to 2<br>
	 * in the output image (same goes for the height of the luminance plane, if
	 * the<br>
	 * chrominance components are subsampled along the vertical dimension.) Also,<br>
	 * each line of each plane in the output image is padded to 4 bytes. Although<br>
	 * this will work with any subsampling option, it is really only useful in<br>
	 * combination with TJ_420, which produces an image compatible with the I420<br>
	 * (AKA "YUV420P") format.<br>
	 * * @param handle a handle to a TurboJPEG compressor or transformer instance<br>
	 * 
	 * @param srcBuf
	 *          pointer to an image buffer containing RGB or grayscale pixels<br>
	 *          to be encoded<br>
	 * @param width
	 *          width (in pixels) of the source image<br>
	 * @param pitch
	 *          bytes per line of the source image. Normally, this should be<br>
	 *          <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is
	 *          unpadded,<br>
	 *          or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line
	 *          of<br>
	 *          the image is padded to the nearest 32-bit boundary, as is the case<br>
	 *          for Windows bitmaps. You can also be clever and use this parameter<br>
	 *          to skip lines, etc. Setting this parameter to 0 is the equivalent
	 *          of<br>
	 *          setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.<br>
	 * @param height
	 *          height (in pixels) of the source image<br>
	 * @param pixelFormat
	 *          pixel format of the source image (see @ref TJPF<br>
	 *          "Pixel formats".)<br>
	 * @param dstBuf
	 *          pointer to an image buffer that will receive the YUV image.<br>
	 *          Use #tjBufSizeYUV() to determine the appropriate size for this
	 *          buffer<br>
	 *          based on the image width, height, and level of chrominance<br>
	 *          subsampling.<br>
	 * @param subsamp
	 *          the level of chrominance subsampling to be used when<br>
	 *          generating the YUV image (see @ref TJSAMP<br>
	 *          "Chrominance subsampling options".)<br>
	 * @param flags
	 *          the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
	 *          "flags".<br>
	 *          * @return 0 if successful, or -1 if an error occurred (see
	 *          #tjGetErrorStr().)<br>
	 *          Original signature :
	 *          <code>int tjEncodeYUV2(tjhandle, unsigned char*, int, int, int, int, unsigned char*, int, int)</code>
	 * <br>
	 *          <i>native declaration :
	 *          libjpeg-turbo\win64\include\turbojpeg.h:639</i>
	 */
	public static native int tjEncodeYUV2(Pointer<?> handle,
																				Pointer<Byte> srcBuf,
																				int width,
																				int pitch,
																				int height,
																				int pixelFormat,
																				Pointer<Byte> dstBuf,
																				int subsamp,
																				int flags);

	/**
	 * Create a TurboJPEG decompressor instance.<br>
	 * * @return a handle to the newly-created instance, or NULL if an error<br>
	 * occurred (see #tjGetErrorStr().)<br>
	 * Original signature : <code>tjhandle tjInitDecompress()</code><br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:650</i>
	 */
	public static native Pointer<?> tjInitDecompress();

	/**
	 * Retrieve information about a JPEG image without decompressing it.<br>
	 * * @param handle a handle to a TurboJPEG decompressor or transformer
	 * instance<br>
	 * 
	 * @param jpegBuf
	 *          pointer to a buffer containing a JPEG image<br>
	 * @param jpegSize
	 *          size of the JPEG image (in bytes)<br>
	 * @param width
	 *          pointer to an integer variable that will receive the width (in<br>
	 *          pixels) of the JPEG image<br>
	 * @param height
	 *          pointer to an integer variable that will receive the height<br>
	 *          (in pixels) of the JPEG image<br>
	 * @param jpegSubsamp
	 *          pointer to an integer variable that will receive the<br>
	 *          level of chrominance subsampling used when compressing the JPEG
	 *          image<br>
	 *          (see @ref TJSAMP "Chrominance subsampling options".)<br>
	 *          * @return 0 if successful, or -1 if an error occurred (see
	 *          #tjGetErrorStr().)<br>
	 *          Original signature :
	 *          <code>int tjDecompressHeader2(tjhandle, unsigned char*, unsigned long, int*, int*, int*)</code>
	 * <br>
	 *          <i>native declaration :
	 *          libjpeg-turbo\win64\include\turbojpeg.h:669</i>
	 */
	public static native int tjDecompressHeader2(	Pointer<?> handle,
																								Pointer<Byte> jpegBuf,
																								@CLong long jpegSize,
																								Pointer<Integer> width,
																								Pointer<Integer> height,
																								Pointer<Integer> jpegSubsamp);

	/**
	 * Returns a list of fractional scaling factors that the JPEG decompressor in<br>
	 * this implementation of TurboJPEG supports.<br>
	 * * @param numscalingfactors pointer to an integer variable that will receive<br>
	 * the number of elements in the list<br>
	 * * @return a pointer to a list of fractional scaling factors, or NULL if an<br>
	 * error is encountered (see #tjGetErrorStr().)<br>
	 * Original signature :
	 * <code>tjscalingfactor* tjGetScalingFactors(int*)</code><br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:684</i>
	 */
	public static native Pointer<tjscalingfactor> tjGetScalingFactors(Pointer<Integer> numscalingfactors);

	/**
	 * Decompress a JPEG image to an RGB or grayscale image.<br>
	 * * @param handle a handle to a TurboJPEG decompressor or transformer
	 * instance<br>
	 * 
	 * @param jpegBuf
	 *          pointer to a buffer containing the JPEG image to decompress<br>
	 * @param jpegSize
	 *          size of the JPEG image (in bytes)<br>
	 * @param dstBuf
	 *          pointer to an image buffer that will receive the decompressed<br>
	 *          image. This buffer should normally be
	 *          <tt>pitch * scaledHeight</tt><br>
	 *          bytes in size, where <tt>scaledHeight</tt> can be determined by<br>
	 *          calling #TJSCALED() with the JPEG image height and one of the
	 *          scaling<br>
	 *          factors returned by #tjGetScalingFactors(). The dstBuf pointer may<br>
	 *          also be used to decompress into a specific region of a larger
	 *          buffer.<br>
	 * @param width
	 *          desired width (in pixels) of the destination image. If this is<br>
	 *          smaller than the width of the JPEG image being decompressed, then<br>
	 *          TurboJPEG will use scaling in the JPEG decompressor to generate
	 *          the<br>
	 *          largest possible image that will fit within the desired width. If<br>
	 *          width is set to 0, then only the height will be considered when<br>
	 *          determining the scaled image size.<br>
	 * @param pitch
	 *          bytes per line of the destination image. Normally, this is<br>
	 *          <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt> if the
	 *          decompressed<br>
	 *          image is unpadded, else <tt>#TJPAD(scaledWidth *<br>
	 *        #tjPixelSize[pixelFormat])</tt> if each line of the decompressed<br>
	 *          image is padded to the nearest 32-bit boundary, as is the case for<br>
	 *          Windows bitmaps. (NOTE: <tt>scaledWidth</tt> can be determined by<br>
	 *          calling #TJSCALED() with the JPEG image width and one of the
	 *          scaling<br>
	 *          factors returned by #tjGetScalingFactors().) You can also be
	 *          clever<br>
	 *          and use the pitch parameter to skip lines, etc. Setting this<br>
	 *          parameter to 0 is the equivalent of setting it to
	 *          <tt>scaledWidth<br>
	 *        * #tjPixelSize[pixelFormat]</tt>.<br>
	 * @param height
	 *          desired height (in pixels) of the destination image. If this<br>
	 *          is smaller than the height of the JPEG image being decompressed,
	 *          then<br>
	 *          TurboJPEG will use scaling in the JPEG decompressor to generate
	 *          the<br>
	 *          largest possible image that will fit within the desired height. If<br>
	 *          height is set to 0, then only the width will be considered when<br>
	 *          determining the scaled image size.<br>
	 * @param pixelFormat
	 *          pixel format of the destination image (see @ref<br>
	 *          TJPF "Pixel formats".)<br>
	 * @param flags
	 *          the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
	 *          "flags".<br>
	 *          * @return 0 if successful, or -1 if an error occurred (see
	 *          #tjGetErrorStr().)<br>
	 *          Original signature :
	 *          <code>int tjDecompress2(tjhandle, unsigned char*, unsigned long, unsigned char*, int, int, int, int, int)</code>
	 * <br>
	 *          <i>native declaration :
	 *          libjpeg-turbo\win64\include\turbojpeg.h:729</i>
	 */
	public static native int tjDecompress2(	Pointer<?> handle,
																					Pointer<Byte> jpegBuf,
																					@CLong long jpegSize,
																					Pointer<Byte> dstBuf,
																					int width,
																					int pitch,
																					int height,
																					int pixelFormat,
																					int flags);

	/**
	 * Decompress a JPEG image to a YUV planar image. This function performs JPEG<br>
	 * decompression but leaves out the color conversion step, so a planar YUV<br>
	 * image is generated instead of an RGB image. The padding of the planes in<br>
	 * this image is the same as the images generated by #tjEncodeYUV2(). Note<br>
	 * that, if the width or height of the image is not an even multiple of the
	 * MCU<br>
	 * block size (see #tjMCUWidth and #tjMCUHeight), then an intermediate buffer<br>
	 * copy will be performed within TurboJPEG.<br>
	 * * @param handle a handle to a TurboJPEG decompressor or transformer
	 * instance<br>
	 * 
	 * @param jpegBuf
	 *          pointer to a buffer containing the JPEG image to decompress<br>
	 * @param jpegSize
	 *          size of the JPEG image (in bytes)<br>
	 * @param dstBuf
	 *          pointer to an image buffer that will receive the YUV image.<br>
	 *          Use #tjBufSizeYUV to determine the appropriate size for this
	 *          buffer<br>
	 *          based on the image width, height, and level of subsampling.<br>
	 * @param flags
	 *          the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
	 *          "flags".<br>
	 *          * @return 0 if successful, or -1 if an error occurred (see
	 *          #tjGetErrorStr().)<br>
	 *          Original signature :
	 *          <code>int tjDecompressToYUV(tjhandle, unsigned char*, unsigned long, unsigned char*, int)</code>
	 * <br>
	 *          <i>native declaration :
	 *          libjpeg-turbo\win64\include\turbojpeg.h:754</i>
	 */
	public static native int tjDecompressToYUV(	Pointer<?> handle,
																							Pointer<Byte> jpegBuf,
																							@CLong long jpegSize,
																							Pointer<Byte> dstBuf,
																							int flags);

	/**
	 * Create a new TurboJPEG transformer instance.<br>
	 * * @return a handle to the newly-created instance, or NULL if an error<br>
	 * occurred (see #tjGetErrorStr().)<br>
	 * Original signature : <code>tjhandle tjInitTransform()</code><br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:765</i>
	 */
	public static native Pointer<?> tjInitTransform();

	/**
	 * Losslessly transform a JPEG image into another JPEG image. Lossless<br>
	 * transforms work by moving the raw coefficients from one JPEG image
	 * structure<br>
	 * to another without altering the values of the coefficients. While this is<br>
	 * typically faster than decompressing the image, transforming it, and<br>
	 * re-compressing it, lossless transforms are not free. Each lossless<br>
	 * transform requires reading and Huffman decoding all of the coefficients in<br>
	 * the source image, regardless of the size of the destination image. Thus,<br>
	 * this function provides a means of generating multiple transformed images<br>
	 * from the same source or of applying multiple transformations
	 * simultaneously,<br>
	 * in order to eliminate the need to read the source coefficients multiple<br>
	 * times.<br>
	 * * @param handle a handle to a TurboJPEG transformer instance<br>
	 * 
	 * @param jpegBuf
	 *          pointer to a buffer containing the JPEG image to transform<br>
	 * @param jpegSize
	 *          size of the JPEG image (in bytes)<br>
	 * @param n
	 *          the number of transformed JPEG images to generate<br>
	 * @param dstBufs
	 *          pointer to an array of n image buffers. <tt>dstBufs[i]</tt><br>
	 *          will receive a JPEG image that has been transformed using the<br>
	 *          parameters in <tt>transforms[i]</tt>. TurboJPEG has the ability to<br>
	 *          reallocate the JPEG buffer to accommodate the size of the JPEG
	 *          image.<br>
	 *          Thus, you can choose to:<br>
	 *          -# pre-allocate the JPEG buffer with an arbitrary size using<br>
	 *          #tjAlloc() and let TurboJPEG grow the buffer as needed,<br>
	 *          -# set <tt>dstBufs[i]</tt> to NULL to tell TurboJPEG to allocate
	 *          the<br>
	 *          buffer for you, or<br>
	 *          -# pre-allocate the buffer to a "worst case" size determined by<br>
	 *          calling #tjBufSize() with the cropped width and height. This
	 *          should<br>
	 *          ensure that the buffer never has to be re-allocated (setting<br>
	 *          #TJFLAG_NOREALLOC guarantees this.)<br>
	 *          .<br>
	 *          If you choose option 1, <tt>dstSizes[i]</tt> should be set to<br>
	 *          the size of your pre-allocated buffer. In any case, unless you
	 *          have<br>
	 *          set #TJFLAG_NOREALLOC, you should always check <tt>dstBufs[i]</tt><br>
	 *          upon return from this function, as it may have changed.<br>
	 * @param dstSizes
	 *          pointer to an array of n unsigned long variables that will<br>
	 *          receive the actual sizes (in bytes) of each transformed JPEG
	 *          image.<br>
	 *          If <tt>dstBufs[i]</tt> points to a pre-allocated buffer, then<br>
	 *          <tt>dstSizes[i]</tt> should be set to the size of the buffer. Upon<br>
	 *          return, <tt>dstSizes[i]</tt> will contain the size of the JPEG
	 *          image<br>
	 *          (in bytes.)<br>
	 * @param transforms
	 *          pointer to an array of n tjtransform structures, each of<br>
	 *          which specifies the transform parameters and/or cropping region
	 *          for<br>
	 *          the corresponding transformed output image.<br>
	 * @param flags
	 *          the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
	 *          "flags".<br>
	 *          * @return 0 if successful, or -1 if an error occurred (see
	 *          #tjGetErrorStr().)<br>
	 *          Original signature :
	 *          <code>int tjTransform(tjhandle, unsigned char*, unsigned long, int, unsigned char**, unsigned long*, tjtransform*, int)</code>
	 * <br>
	 *          <i>native declaration :
	 *          libjpeg-turbo\win64\include\turbojpeg.h:817</i>
	 */
	public static native int tjTransform(	Pointer<?> handle,
																				Pointer<Byte> jpegBuf,
																				@CLong long jpegSize,
																				int n,
																				Pointer<Pointer<Byte>> dstBufs,
																				Pointer<CLong> dstSizes,
																				Pointer<tjtransform> transforms,
																				int flags);

	/**
	 * Destroy a TurboJPEG compressor, decompressor, or transformer instance.<br>
	 * * @param handle a handle to a TurboJPEG compressor, decompressor or<br>
	 * transformer instance<br>
	 * * @return 0 if successful, or -1 if an error occurred (see
	 * #tjGetErrorStr().)<br>
	 * Original signature : <code>int tjDestroy(tjhandle)</code><br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:830</i>
	 */
	public static native int tjDestroy(Pointer<?> handle);

	/**
	 * Allocate an image buffer for use with TurboJPEG. You should always use<br>
	 * this function to allocate the JPEG destination buffer(s) for #tjCompress2()<br>
	 * and #tjTransform() unless you are disabling automatic buffer<br>
	 * (re)allocation (by setting #TJFLAG_NOREALLOC.)<br>
	 * * @param bytes the number of bytes to allocate<br>
	 * <br>
	 * 
	 * @return a pointer to a newly-allocated buffer with the specified number of<br>
	 *         bytes<br>
	 *         * @sa tjFree()<br>
	 *         Original signature : <code>char* tjAlloc(int)</code><br>
	 *         <i>native declaration :
	 *         libjpeg-turbo\win64\include\turbojpeg.h:846</i>
	 */
	public static native Pointer<Byte> tjAlloc(int bytes);

	/**
	 * Free an image buffer previously allocated by TurboJPEG. You should always<br>
	 * use this function to free JPEG destination buffer(s) that were
	 * automatically<br>
	 * (re)allocated by #tjCompress2() or #tjTransform() or that were manually<br>
	 * allocated using #tjAlloc().<br>
	 * * @param buffer address of the buffer to free<br>
	 * * @sa tjAlloc()<br>
	 * Original signature : <code>void tjFree(unsigned char*)</code><br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:859</i>
	 */
	public static native void tjFree(Pointer<Byte> buffer);

	/**
	 * Returns a descriptive error message explaining why the last command failed.<br>
	 * * @return a descriptive error message explaining why the last command
	 * failed.<br>
	 * Original signature : <code>char* tjGetErrorStr()</code><br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:867</i>
	 */
	public static native Pointer<Byte> tjGetErrorStr();

	/**
	 * Original signature : <code>long TJBUFSIZE(int, int)</code><br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:888</i>
	 */
	@CLong
	public static native long TJBUFSIZE(int width, int height);

	/**
	 * Original signature : <code>long TJBUFSIZEYUV(int, int, int)</code><br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:890</i>
	 */
	@CLong
	public static native long TJBUFSIZEYUV(	int width,
																					int height,
																					int jpegSubsamp);

	/**
	 * Original signature :
	 * <code>int tjCompress(tjhandle, unsigned char*, int, int, int, int, unsigned char*, unsigned long*, int, int, int)</code>
	 * <br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:893</i>
	 */
	public static native int tjCompress(Pointer<?> handle,
																			Pointer<Byte> srcBuf,
																			int width,
																			int pitch,
																			int height,
																			int pixelSize,
																			Pointer<Byte> dstBuf,
																			Pointer<CLong> compressedSize,
																			int jpegSubsamp,
																			int jpegQual,
																			int flags);

	/**
	 * Original signature :
	 * <code>int tjEncodeYUV(tjhandle, unsigned char*, int, int, int, int, unsigned char*, int, int)</code>
	 * <br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:897</i>
	 */
	public static native int tjEncodeYUV(	Pointer<?> handle,
																				Pointer<Byte> srcBuf,
																				int width,
																				int pitch,
																				int height,
																				int pixelSize,
																				Pointer<Byte> dstBuf,
																				int subsamp,
																				int flags);

	/**
	 * Original signature :
	 * <code>int tjDecompressHeader(tjhandle, unsigned char*, unsigned long, int*, int*)</code>
	 * <br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:901</i>
	 */
	public static native int tjDecompressHeader(Pointer<?> handle,
																							Pointer<Byte> jpegBuf,
																							@CLong long jpegSize,
																							Pointer<Integer> width,
																							Pointer<Integer> height);

	/**
	 * Original signature :
	 * <code>int tjDecompress(tjhandle, unsigned char*, unsigned long, unsigned char*, int, int, int, int, int)</code>
	 * <br>
	 * <i>native declaration : libjpeg-turbo\win64\include\turbojpeg.h:904</i>
	 */
	public static native int tjDecompress(Pointer<?> handle,
																				Pointer<Byte> jpegBuf,
																				@CLong long jpegSize,
																				Pointer<Byte> dstBuf,
																				int width,
																				int pitch,
																				int height,
																				int pixelSize,
																				int flags);
}
