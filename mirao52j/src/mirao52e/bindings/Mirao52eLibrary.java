package mirao52e.bindings;

import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.Pointer;
import org.bridj.TimeT;
import org.bridj.ann.Convention;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;

/**
 * Wrapper for library <b>mirao52e</b><br>
 * This file was autogenerated by
 * <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that
 * <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a
 * few opensource projects.</a>.<br>
 * For help, please visit
 * <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or
 * <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("mirao52e")
@Runtime(CRuntime.class)
public class Mirao52eLibrary
{
  static
  {
    BridJ.register();
  }
  /** No error detected. */
  public static final int MRO_OK = 0;
  /**
   * Unknown error.<br>
   * Indicates an error of unknown provenance <br>
   * has been detected.
   */
  public static final int MRO_UNKNOWN_ERROR = 1;
  /**
   * mirao 52-e device is not opened.<br>
   * Indicates a successful call to mro_open must be done <br>
   * before calling other functions.
   */
  public static final int MRO_DEVICE_NOT_OPENED_ERROR = 2;
  /**
   * mirao 52-e device has been identified as defective.<br>
   * The hardware configuration of the mirao 52-e device seems to be defective.
   */
  public static final int MRO_DEFECTIVE_DEVICE_ERROR = 3;
  /**
   * mirao 52-e is already opened.<br>
   * You try to call twice the mro_open function without having <br>
   * closed mirao 52-e device before.
   */
  public static final int MRO_DEVICE_ALREADY_OPENED_ERROR = 4;
  /**
   * A communication error has been detected.<br>
   * mirao 52-e device has detected a communication anomaly.
   */
  public static final int MRO_DEVICE_IO_ERROR = 5;
  /**
   * mirao 52-e is locked.<br>
   * A temperature overheat or an excess of current has lead mirao 52-e<br>
   * to a protection state.<br>
   * A zero command has been applied waiting for device safety and <br>
   * you are not allowed to apply commands till it.<br>
   * <br>
   * <i>This error is raised only if the monitoring is enabled</i>.
   */
  public static final int MRO_DEVICE_LOCKED_ERROR = 6;
  /**
   * mirao 52-e seems to be disconnected.<br>
   * The connection with mirao 52-e has been lost. Check cables.<br>
   * <br>
   * <i>This error is raised only if the monitoring is enabled</i>.
   */
  public static final int MRO_DEVICE_DISCONNECTED_ERROR = 7;
  /** This error indicates an internal driver malfunction. */
  public static final int MRO_DEVICE_DRIVER_ERROR = 8;
  /**
   * The file already exists.<br>
   * The file to write already exists and it's not allowed <br>
   * to overwrite it.
   */
  public static final int MRO_FILE_EXISTS_ERROR = 9;
  /**
   * Bad file format.<br>
   * The considered file is corrupted or has not a valid file format.
   */
  public static final int MRO_FILE_FORMAT_ERROR = 10;
  /**
   * An error has been detected while reading/writing a file.<br>
   * This error can indicate a problem with the hard drive.
   */
  public static final int MRO_FILE_IO_ERROR = 11;
  /**
   * Invalid command.<br>
   * There are two possibilities: <br>
   * <br>
   * - A least one of the values of the command is out of specification (value >
   * 1.0 or value < -1.0).<br>
   * - The sum of the absolute values of the command's values is greater than
   * 25.0.
   */
  public static final int MRO_INVALID_COMMAND_ERROR = 12;
  /**
   * Null pointer error.<br>
   * A null pointer has been identified as a parameter which cannot be null.
   */
  public static final int MRO_NULL_POINTER_ERROR = 13;
  /**
   * A parameter is out of accepted bounds.<br>
   * This happens when an index parameter is out of its possible values.
   */
  public static final int MRO_OUT_OF_BOUNDS_ERROR = 14;
  /**
   * Operation already in progress.<br>
   * The requested operation cannot be performed due to a synchronization lock.
   */
  public static final int MRO_OPERATION_ONGOING_ERROR = 15;
  /**
   * Operating system error.<br>
   * An error has been detected while calling the operating system.
   */
  public static final int MRO_SYSTEM_ERROR = 16;
  /**
   * The requested data is unavailable.<br>
   * This can be due to the call of an unavailable functionality or a <br>
   * functionality that needs monitoring to be enabled.
   */
  public static final int MRO_UNAVAILABLE_DATA_ERROR = 17;
  /**
   * Undefined value.<br>
   * The requested value is not available. Ex: request of an undefined stock
   * command value.
   */
  public static final int MRO_UNDEFINED_VALUE_ERROR = 18;
  /**
   * A parameter has an out of specifications value.<br>
   * The value, which is not an index, is out of allowed values.
   */
  public static final int MRO_OUT_OF_SPECIFICATIONS_ERROR = 19;
  /**
   * The file format version is not supported.<br>
   * The version of the MRO file format is not handled by this mirao 52-e API.
   */
  public static final int MRO_FILE_FORMAT_VERSION_ERROR = 20;
  /**
   * Invalid handle.<br>
   * This error implies either an operating system error or an internal driver
   * error.
   */
  public static final int MRO_USB_INVALID_HANDLE = 21;
  /**
   * mirao 52-e cannot be found.<br>
   * mirao 52-e device cannot be found among the USB ports.<br>
   * There may be several possibilities:<br>
   * - The device is not connected to the computer or the connection is
   * defective,<br>
   * - The USB port is not correctly installed in the operating system,<br>
   * - The mirao 52-e device is not turned ON,<br>
   * - The mirao 52-e device is already opened by another process,<br>
   * - The mirao 52-e device is defective.
   */
  public static final int MRO_USB_DEVICE_NOT_FOUND = 22;
  /**
   * Internal driver not opened.<br>
   * This error implies an operating system error.
   */
  public static final int MRO_USB_DEVICE_NOT_OPENED = 23;
  /**
   * Internal driver IO error.<br>
   * The internal driver encountered a problem for reading from or writing to
   * the<br>
   * hardware device.
   */
  public static final int MRO_USB_IO_ERROR = 24;
  /**
   * Insufficient resources.<br>
   * There are insufficient system resources to perform the requested operation.
   */
  public static final int MRO_USB_INSUFFICIENT_RESOURCES = 25;
  /**
   * Invalid baud rate.<br>
   * The configuration of the connection speed is not supported.
   */
  public static final int MRO_USB_INVALID_BAUD_RATE = 26;
  /**
   * Operation not supported.<br>
   * A functionnality is not supported by the internal driver. Implies an
   * operating <br>
   * system error perhaps due to a bad USB driver version.
   */
  public static final int MRO_USB_NOT_SUPPORTED = 27;
  /**
   * Permission denied.<br>
   * A file cannot be accessed due to a permission denied error.
   */
  public static final int MRO_FILE_IO_EACCES = 28;
  /**
   * No more processes.<br>
   * An attempt to create a new process failed.
   */
  public static final int MRO_FILE_IO_EAGAIN = 29;
  /**
   * Bad file number.<br>
   * An invalid internal file descriptor has been used.<br>
   * This is an operating system error.
   */
  public static final int MRO_FILE_IO_EBADF = 30;
  /**
   * Invalid argument.<br>
   * An internal invalid argument has been used with a file IO function.<br>
   * This is an operating system error.
   */
  public static final int MRO_FILE_IO_EINVAL = 31;
  /**
   * Too many opened files.<br>
   * The maximum number of open files allowed by the operating system has been
   * reached.
   */
  public static final int MRO_FILE_IO_EMFILE = 32;
  /**
   * No such file or directory.<br>
   * The considered file or directory does not exists.
   */
  public static final int MRO_FILE_IO_ENOENT = 33;
  /**
   * Not enough memory.<br>
   * The operation requested cannot be performed because the process is out of
   * memory.
   */
  public static final int MRO_FILE_IO_ENOMEM = 34;
  /**
   * No space left on device.<br>
   * A file cannot be written because the hard drive lacks of space.
   */
  public static final int MRO_FILE_IO_ENOSPC = 35;
  /** <i>native declaration : lib\mirao52e\mirao52e.h</i> */
  public static final int MRO_FALSE = (int) 0;
  /** <i>native declaration : lib\mirao52e\mirao52e.h</i> */
  public static final int MRO_NB_COMMAND_VALUES = (int) 52;
  /** <i>native declaration : lib\mirao52e\mirao52e.h</i> */
  public static final int MRO_TRUE = (int) 1;

  /** <i>native declaration : lib\mirao52e\mirao52e.h:1266</i> */
  public static abstract class MroRegisterCallbackCallbackCallback extends
                                                                   Callback<MroRegisterCallbackCallbackCallback>
  {
    public void apply(Pointer<MroInfo> MiraoInfoPtr1)
    {
      apply(Pointer.getPeer(MiraoInfoPtr1));
    }

    public void apply(@Ptr long MiraoInfoPtr1)
    {
      apply((Pointer) Pointer.pointerToAddress(MiraoInfoPtr1,
                                               MroInfo.class));
    }
  };

  /**
   * Indicates the mirao 52-e DLL version.<br>
   * Returns a null terminated character string containing the version of the
   * <br>
   * mirao 52-e DLL. The format of the version is "xxx.xxx.yyyymmdd".<br>
   * <br>
   * 
   * @param version
   *          Pointer to a character string to put the version.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the version has been copied into <i>version</i>, <br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_NULL_POINTER_ERROR The parameter <i>version</i> is null.<br>
   *        Original signature :
   *        <code>MroBoolean mro_getVersion(char*, int*)</code><br>
   *        <i>native declaration : lib\mirao52e\mirao52e.h:370</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getVersion")
  public static byte mroGetVersion(Pointer<Byte> version,
                                   Pointer<Integer> status)
  {
    return mroGetVersion(Pointer.getPeer(version),
                         Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getVersion")
  protected native static byte mroGetVersion(@Ptr long version,
                                             @Ptr long status);

  /**
   * Opens mirao 52-e.<br>
   * Starts the communication with the mirao 52-e device and initializes it.
   * <br>
   * <br>
   * At starting, the mirao 52-e device has a geometry of a command composed of
   * a set<br>
   * of null values. <br>
   * <br>
   * The monitoring is disable at starting. <br>
   * <br>
   * This function must be called before all the others (except mro_getVersion,
   * <br>
   * mro_readCommandFile and mro_writeCommandFile).<br>
   * <br>
   * 
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if mirao 52-e device is successfully opened, <br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_ALREADY_OPENED_ERROR The mirao 52-e device is already
   *        opened.<br>
   * @throw MRO_DEFECTIVE_DEVICE_ERROR The hardware configuration of the mirao
   *        52-e device seems to be invalid.<br>
   * @throw MRO_DEVICE_IO_ERROR A communication error with the mirao 52-e device
   *        occured.<br>
   * @throw MRO_DEVCIE_DRIVER_ERROR An error occured while using the USB
   *        driver.<br>
   * @throw MRO_USB_INVALID_HANDLE The handle of the USB port is no more
   *        valid.<br>
   * @throw MRO_USB_DEVICE_NOT_FOUND The mirao device cannot be found.<br>
   * @throw MRO_USB_DEVICE_NOT_OPENED The USB port is not opened.<br>
   * @throw MRO_USB_IO_ERROR A communication error with the USB port
   *        occured.<br>
   * @throw MRO_USB_INSUFFICIENT_RESOURCES Insufficient system resources to
   *        perform the operation on the USB port.<br>
   * @throw MRO_USB_INVALID_BAUD_RATE The USB port baud rate configuration is
   *        invalid.<br>
   * @throw MRO_USB_NOT_SUPPORTED The function is not supported by the USB
   *        driver.<br>
   *        <br>
   * @see mro_close<br>
   *      Original signature : <code>MroBoolean mro_open(int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:405</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_openz")
  public static byte mroOpen(Pointer<Integer> status)
  {
    return mroOpen(Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_open")
  protected native static byte mroOpen(@Ptr long status);

  /**
   * Closes mirao 52-e.<br>
   * Resets the geometry with a command composed of null values, disables
   * the<br>
   * monitoring if it is enabled and closes the communication with the
   * hardware.<br>
   * <br>
   * 
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the mirao 52-e device is successfully closed,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_DEVICE_IO_ERROR A communication error with the mirao 52-e device
   *        occured.<br>
   * @throw MRO_DEVICE_DRIVER_ERROR An error occured while using the USB
   *        port.<br>
   * @throw MRO_USB_INVALID_HANDLE The handle of the USB port is not more
   *        valid.<br>
   * @throw MRO_USB_DEVICE_NOT_OPENED The device is not opened.<br>
   * @throw MRO_USB_IO_ERROR A communication error on the USB port occured.<br>
   * @throw MRO_USB_INSUFFICIENT_RESOURCES Insufficient system resources to
   *        perform the operation on the USB port.<br>
   * @throw MRO_USB_NOT_SUPPORTED The function is not supported by the USB
   *        driver.<br>
   *        <br>
   * @see mro_open<br>
   *      Original signature : <code>MroBoolean mro_close(int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:432</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_close")
  public static byte mroClose(Pointer<Integer> status)
  {
    return mroClose(Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_close")
  protected native static byte mroClose(@Ptr long status);

  /**
   * Applies a standard command to the mirror.<br>
   * The function modifies the geometry of the mirror<br>
   * according to the set of values contained in <i>command</i>. <br>
   * <br>
   * If <i>trig</i> is MRO_TRUE, a hardware trig follow the application. <br>
   * <br>
   * With this function, the geometry of the mirror is changed as quickly as<br>
   * possible.<br>
   * <br>
   * 
   * @param command
   *          Command to apply to the mirror.<br>
   *          <br>
   * @param trig
   *          If MRO_TRUE, a hardware trig will follow the command<br>
   *          application.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the command has been successfully sent to the
   *         mirror,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_INVALID_COMMAND_ERROR The set of values contained in
   *        <i>command</i> is invalid.<br>
   * @throw MRO_NULL_POINTER_ERROR The parameter <i>command</i> is NULL.<br>
   * @throw MRO_DEVICE_IO_ERROR A communication error with the mirao 52-e device
   *        occured.<br>
   * @throw MRO_DEVICE_LOCKED_ERROR The mirao 52-e device is locked.<br>
   * @throw MRO_DEVICE_DRIVER_ERROR An error occured while using the USB
   *        driver.<br>
   * @throw MRO_USB_INVALID_HANDLE The handle of the USB port is not more
   *        valid.<br>
   * @throw MRO_USB_DEVICE_NOT_OPENED The device is not opened.<br>
   * @throw MRO_USB_IO_ERROR A communication error on the USB port occured.<br>
   * @throw MRO_USB_INSUFFICIENT_RESOURCES Insufficient system resources to
   *        perform the operation on the USB port.<br>
   * @throw MRO_USB_NOT_SUPPORTED The function is not supported by the USB
   *        driver.<br>
   * @throw MRO_DEVICE_DISCONNECTED A communication problem with the mirao 52-e
   *        device has been detected.<br>
   *        <br>
   * @see MroCommand<br>
   * @see mro_applySmoothCommand<br>
   * @see mro_applyStockCommand<br>
   * @see mro_applySmoothStockCommand<br>
   *      Original signature :
   *      <code>MroBoolean mro_applyCommand(MroCommand, MroBoolean, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:479</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_applyCommand")
  public static byte mroApplyCommand(Pointer<Double> command,
                                     byte trig,
                                     Pointer<Integer> status)
  {
    return mroApplyCommand(Pointer.getPeer(command),
                           trig,
                           Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_applyCommand")
  protected native static byte mroApplyCommand(@Ptr long command,
                                               byte trig,
                                               @Ptr long status);

  /**
   * Not documented.<br>
   * Original signature :
   * <code>MroBoolean mro_applyIoCommand(MroCommand, MroBoolean, int*)</code><br>
   * <i>native declaration : lib\mirao52e\mirao52e.h:489</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_applyIoCommand")
  public static byte mroApplyIoCommand(Pointer<Double> command,
                                       byte trig,
                                       Pointer<Integer> status)
  {
    return mroApplyIoCommand(Pointer.getPeer(command),
                             trig,
                             Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_applyIoCommand")
  protected native static byte mroApplyIoCommand(@Ptr long command,
                                                 byte trig,
                                                 @Ptr long status);

  /**
   * Applies a smooth command to the mirror.<br>
   * This function modifies the geometry of the mirror according to the set
   * of<br>
   * values contained in <i>command</i>. <br>
   * <br>
   * With this function, the geometry of the mirror is modified without <br>
   * vibrations but taking a little more time than with the
   * <i>mro_applyCommand</i><br>
   * function. <br>
   * <br>
   * If <i>trig</i> is MRO_TRUE, a hardware trig follow the application. <br>
   * <br>
   * <br>
   * 
   * @param command
   *          Command to apply to the mirror.<br>
   * @param trig
   *          If MRO_TRUE, a hardware trig follow the command<br>
   *          application.<br>
   * @param status
   *          Pointer to an integer containing the error code if an<br>
   *          error occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the command has been successfully sent to the
   *         mirror,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_INVALID_COMMAND_ERROR The set of values contained in
   *        <i>command</i> is invalid.<br>
   * @throw MRO_NULL_POINTER_ERROR The parameter <i>command</i> is NULL.<br>
   * @throw MRO_DEVICE_IO_ERROR A communication error with the mirao 52-e device
   *        occured.<br>
   * @throw MRO_DEVICE_LOCKED_ERROR The mirao 52-e device is in protection
   *        mode.<br>
   * @throw MRO_DEVICE_DRIVER_ERROR An error occured while using the USB
   *        driver.<br>
   * @throw MRO_USB_INVALID_HANDLE The handle of the USB port is not more
   *        valid.<br>
   * @throw MRO_USB_DEVICE_NOT_OPENED The USB port is not opened.<br>
   * @throw MRO_USB_IO_ERROR A communication error on the USB port occured.<br>
   * @throw MRO_USB_INSUFFICIENT_RESOURCES Insufficient system resources to
   *        perform the operation on the USB port.<br>
   * @throw MRO_USB_NOT_SUPPORTED The function is not supported by the USB
   *        driver.<br>
   * @throw MRO_DEVICE_DISCONNECTED A communication problem with the mirao 52-e
   *        device has been detected.<br>
   *        <br>
   * @see MroCommand<br>
   * @see mro_applyCommand<br>
   * @see mro_applyStockCommand<br>
   * @see mro_applySmoothStockCommand<br>
   *      Original signature :
   *      <code>MroBoolean mro_applySmoothCommand(MroCommand, MroBoolean, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:532</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_applySmoothCommand")
  public static byte mroApplySmoothCommand(Pointer<Double> command,
                                           byte trig,
                                           Pointer<Integer> status)
  {
    return mroApplySmoothCommand(Pointer.getPeer(command),
                                 trig,
                                 Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_applySmoothCommand")
  protected native static byte mroApplySmoothCommand(@Ptr long command,
                                                     byte trig,
                                                     @Ptr long status);

  /**
   * Indicates the last command applied to the mirror.<br>
   * The last command applied to the mirror is copied into <i>command</i>. <br>
   * <br>
   * The last applied command is the last command applied to the mirror by
   * the<br>
   * user, or by the DLL in the functions mro_open and after a connection <br>
   * recovering.<br>
   * <br>
   * 
   * @param command
   *          Array where the last applied command is copied.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an<br>
   *          error occurs or MRO_OK if the call returns<br>
   *          successfully.<br>
   *          <br>
   * @return MRO_TRUE if the last applied command has been copied in
   *         <i>command</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>command</i> is
   *        NULL.<br>
   *        <br>
   * @see MroCommand<br>
   * @see mro_getLastAppliedCommandDate<br>
   *      Original signature :
   *      <code>MroBoolean mro_getLastAppliedCommand(MroCommand, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:561</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getLastAppliedCommand")
  public static byte mroGetLastAppliedCommand(Pointer<Double> command,
                                              Pointer<Integer> status)
  {
    return mroGetLastAppliedCommand(Pointer.getPeer(command),
                                    Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getLastAppliedCommand")
  protected native static byte mroGetLastAppliedCommand(@Ptr long command,
                                                        @Ptr long status);

  /**
   * Indicates the date of the last command application.<br>
   * Returns the date corresponding to the application of the command available
   * <br>
   * through the function mro_getLastAppliedCommand. <br>
   * <br>
   * The date is second precise.<br>
   * <br>
   * 
   * @param date
   *          Pointer to the MroDate variable where date is copied.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an<br>
   *          error occurs or MRO_OK if the call returns<br>
   *          successfully.<br>
   *          <br>
   * @return MRO_TRUE if the last applied command date is copied in
   *         <i>date</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>status</i> is
   *        NULL.<br>
   *        <br>
   * @see MroDate<br>
   * @see mro_getLastAppliedCommand<br>
   *      Original signature :
   *      <code>MroBoolean mro_getLastAppliedCommandDate(MroDate*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:588</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getLastAppliedCommandDate")
  public static byte mroGetLastAppliedCommandDate(Pointer<TimeT> date,
                                                  Pointer<Integer> status)
  {
    return mroGetLastAppliedCommandDate(Pointer.getPeer(date),
                                        Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getLastAppliedCommandDate")
  protected native static byte mroGetLastAppliedCommandDate(@Ptr long date,
                                                            @Ptr long status);

  /**
   * Inserts a command into the stock.<br>
   * This function allows to insert a command into the stock. The command<br>
   * is stored in the stock at the position specified by <i>index</i>. <br>
   * <br>
   * If a command has already been stored at <i>index</i> in the stock, it
   * is<br>
   * overwritten without warning.<br>
   * <br>
   * 
   * @param command
   *          Command to add to the command stock.<br>
   *          <br>
   * @param index
   *          Index of the command stock where to put the command.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an<br>
   *          error occurs or MRO_OK if the call returns<br>
   *          successfully.<br>
   *          <br>
   * @return MRO_TRUE if the command is added to the command stock,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_INVALID_COMMAND_ERROR The set of values contained in
   *        <i>command</i> is invalid.<br>
   * @throw MRO_NULL_POINTER_ERROR The parameter <i>command</i> is NULL.<br>
   * @throw MRO_OUT_OF_BOUNDS_ERROR The value of the parameter <i>index</i> is
   *        out of range.<br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The device is not opened.<br>
   *        <br>
   * @see MroCommand<br>
   * @see mro_getStockCommand<br>
   * @see mro_isStockCommandDefined<br>
   * @see mro_removeStockCommand<br>
   *      Original signature :
   *      <code>MroBoolean mro_setStockCommand(MroCommand, int, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:628</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_setStockCommand")
  public static byte mroSetStockCommand(Pointer<Double> command,
                                        int index,
                                        Pointer<Integer> status)
  {
    return mroSetStockCommand(Pointer.getPeer(command),
                              index,
                              Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_setStockCommand")
  protected native static byte mroSetStockCommand(@Ptr long command,
                                                  int index,
                                                  @Ptr long status);

  /**
   * Retrieves a command from the stock.<br>
   * This function allows to get a command stored into the command stock at
   * the<br>
   * position specified by <i>index</i>. <br/>
   * <br>
   * The command must have been stored in the command stock using <br>
   * mro_setStockCommand. <br>
   * <br>
   * 
   * @param command
   *          Pointer to the array where to put the retrieved command.<br>
   * @param index
   *          Index of the command stock of the command to retrieve.<br>
   * @param status
   *          Pointer to an integer containing the error code if an<br>
   *          error occurs or MRO_OK if the call returns<br>
   *          successfully.<br>
   *          <br>
   * @return MRO_TRUE if the command is retrieved from the command stock,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_OUT_OF_BOUNDS_ERROR The value of the parameter <i>index</i> is
   *        out of range.<br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_UNDEFINED_VALUE_ERROR The command specified by <i>index</i> is
   *        not defined in the stock.<br>
   * @throw MRO_NULL_POINTER_ERROR The parameter <i>command</i> is NULL.<br>
   *        <br>
   * @see MroCommand<br>
   * @see mro_setStockCommand<br>
   * @see mro_isStockCommandDefined<br>
   *      Original signature :
   *      <code>MroBoolean mro_getStockCommand(MroCommand, int, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:660</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getStockCommand")
  public static byte mroGetStockCommand(Pointer<Double> command,
                                        int index,
                                        Pointer<Integer> status)
  {
    return mroGetStockCommand(Pointer.getPeer(command),
                              index,
                              Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getStockCommand")
  protected native static byte mroGetStockCommand(@Ptr long command,
                                                  int index,
                                                  @Ptr long status);

  /**
   * Applies a command from the stock to the mirror.<br>
   * The geometry of the mirror is modified according to the command stored
   * in<br>
   * the stock at <i>index</i>. <br>
   * <br>
   * The modification of the geometry is performed as quickly as possible. <br>
   * <br>
   * The command must have been stored in the stock using
   * mro_setStockCommand.<br>
   * <br>
   * 
   * @param index
   *          Index of the command stock of the command to apply.<br>
   *          <br>
   * @param trig
   *          If MRO_TRUE, a hardware trig follow the command application.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an<br>
   *          error occurs or MRO_OK if the call returns<br>
   *          successfully.<br>
   *          <br>
   * @return MRO_TRUE if the command is successfully sent to the mirror,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_DEVICE_IO_ERROR A communication error with the mirao 52-e device
   *        occured.<br>
   * @throw MRO_DEVICE_LOCKED_ERROR The mirao 52-e device is locked.<br>
   * @throw MRO_OUT_OF_BOUNDS_ERROR The value of the parameter <i>index</i> is
   *        out of range.<br>
   * @throw MRO_UNDEFINED_VALUE_ERROR The command specified by <i>index</i> is
   *        not defined in the stock.<br>
   * @throw MRO_DEVICE_DISCONNECTED_ERROR A connection problem with the mirao
   *        52-e device has been detected.<br>
   * @throw MRO_DEVICE_DRIVER_ERROR An error occured using the USB driver.<br>
   * @throw MRO_USB_INVALID_HANDLE The handle of the USB port is not more
   *        valid.<br>
   * @throw MRO_USB_DEVICE_NOT_OPENED The USB port is not opened.<br>
   * @throw MRO_USB_IO_ERROR A communcation error occured on the USB port.<br>
   * @throw MRO_USB_INSUFFICIENT_RESOURCES System resources are insufficient to
   *        perform the operation.<br>
   * @throw MRO_USB_NOT_SUPPORTED The function is not supported by the USB
   *        driver.<br>
   *        <br>
   * @see mro_setStockCommand<br>
   * @see mro_applySmoothStockCommand<br>
   * @see mro_applyCommand<br>
   * @see mro_applySmoothCommand<br>
   *      Original signature :
   *      <code>MroBoolean mro_applyStockCommand(int, MroBoolean, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:703</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_applyStockCommand")
  public static byte mroApplyStockCommand(int index,
                                          byte trig,
                                          Pointer<Integer> status)
  {
    return mroApplyStockCommand(index, trig, Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_applyStockCommand")
  protected native static byte mroApplyStockCommand(int index,
                                                    byte trig,
                                                    @Ptr long status);

  /**
   * Applies a smooth command from the stock to the mirror.<br>
   * The geometry of the mirror is modified according to the command stored
   * in<br>
   * the stock at <i>index</i>. <br>
   * <br>
   * With this function, the geometry of the mirror is modified without <br>
   * vibrations but taking a little more time than with
   * <i>mro_applyStockCommand</i>. <br>
   * <br>
   * The command must have been stored in the stock using
   * mro_setStockCommand.<br>
   * <br>
   * 
   * @param index
   *          Index of the command stock of the command to apply.<br>
   *          <br>
   * @param trig
   *          If MRO_TRUE, a hardware trig follow the command application.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an<br>
   *          error occurs or MRO_OK if the call returns<br>
   *          successfully.<br>
   *          <br>
   * @return MRO_TRUE if the command is successfully sent to the mirror,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_DEVICE_IO_ERROR A communication error with the mirao 52-e device
   *        occured.<br>
   * @throw MRO_DEVICE_LOCKED_ERROR The mirao 52-e device is in protection
   *        mode.<br>
   * @throw MRO_OUT_OF_BOUNDS_ERROR The value of the parameter <i>index</i> is
   *        out of range.<br>
   * @throw MRO_UNDEFINED_VALUE_ERROR The command specified by <i>index</i> is
   *        not defined in the stock.<br>
   * @throw MRO_DEVICE_DISCONNECTED_ERROR A connection problem with the mirao
   *        52-e device has been detected.<br>
   * @throw MRO_DEVICE_DRIVER_ERROR An error occured using the USB driver.<br>
   * @throw MRO_USB_INVALID_HANDLE The handle of the USB port is not more
   *        valid.<br>
   * @throw MRO_USB_DEVICE_NOT_OPENED The USB port is not opened.<br>
   * @throw MRO_USB_IO_ERROR A communication error occured on the USB port.<br>
   * @throw MRO_USB_INSUFFICIENT_RESOURCES System resources are insufficient to
   *        perform the operation.<br>
   * @throw MRO_USB_NOT_SUPPORTED The function is not supported by the USB
   *        driver.<br>
   *        <br>
   * @see mro_setStockCommand<br>
   * @see mro_applyStockCommand<br>
   * @see mro_applyCommand<br>
   * @see mro_applySmoothStockCommand<br>
   *      Original signature :
   *      <code>MroBoolean mro_applySmoothStockCommand(int, MroBoolean, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:747</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_applySmoothStockCommand")
  public static byte mroApplySmoothStockCommand(int index,
                                                byte trig,
                                                Pointer<Integer> status)
  {
    return mroApplySmoothStockCommand(index,
                                      trig,
                                      Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_applySmoothStockCommand")
  protected native static byte mroApplySmoothStockCommand(int index,
                                                          byte trig,
                                                          @Ptr long status);

  /**
   * Removes a command of the stock.<br>
   * Deletes the command stored in the command stock at <i>index</i>. <br>
   * <br>
   * No warning if the command is not defined.<br>
   * <br>
   * 
   * @param index
   *          Command of the command stock to remove.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the command is successfully removed,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_OUT_OF_BOUNDS_ERROR The value of the parameter <i>index</i> is
   *        out of range.<br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The device is not opened.<br>
   *        <br>
   * @see mro_setStockCommand<br>
   * @see mro_resetCommandStock<br>
   *      Original signature :
   *      <code>MroBoolean mro_removeStockCommand(int, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:773</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_removeStockCommand")
  public static byte mroRemoveStockCommand(int index,
                                           Pointer<Integer> status)
  {
    return mroRemoveStockCommand(index, Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_removeStockCommand")
  protected native static byte mroRemoveStockCommand(int index,
                                                     @Ptr long status);

  /**
   * Indicates if a stock contains a command at the specified index.<br>
   * Return whether the command stored in the stock at <i>index</i> is
   * defined<br>
   * or not.<br>
   * <br>
   * 
   * @param index
   *          Index of the command stock.<br>
   *          <br>
   * @param result
   *          Pointer to a MroBoolean where to put the result.<br>
   *          (MRO_TRUE if the command is defined, else MRO_FALSE)<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the result is put in <i>result</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_OUT_OF_BOUNDS_ERROR The value of the parameter <i>index</i> is
   *        out of range.<br>
   * @throw MRO_NULL_POINTER_ERROR The parameter <i>result</i> is NULL.<br>
   *        <br>
   * @see MroBoolean<br>
   * @see mro_setStockCommand<br>
   *      Original signature :
   *      <code>MroBoolean mro_isStockCommandDefined(int, MroBoolean*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:802</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_isStockCommandDefined")
  public static byte mroIsStockCommandDefined(int index,
                                              Pointer<Byte> result,
                                              Pointer<Integer> status)
  {
    return mroIsStockCommandDefined(index,
                                    Pointer.getPeer(result),
                                    Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_isStockCommandDefined")
  protected native static byte mroIsStockCommandDefined(int index,
                                                        @Ptr long result,
                                                        @Ptr long status);

  /**
   * Clears the stock.<br>
   * Removes all the command defined in the stock.<br>
   * <br>
   * 
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the command stock is emptied,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The device is not opened.<br>
   *        <br>
   * @see mro_removeStockCommand<br>
   * @see mro_setStockCommand<br>
   *      Original signature :
   *      <code>MroBoolean mro_resetCommandStock(int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:824</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_resetCommandStock")
  public static byte mroResetCommandStock(Pointer<Integer> status)
  {
    return mroResetCommandStock(Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_resetCommandStock")
  protected native static byte mroResetCommandStock(@Ptr long status);

  /**
   * Indicates the number of commands in the stock.<br>
   * Returns the number of commands defined in the stock.<br>
   * <br>
   * 
   * @param size
   *          Pointer to an integer to put the number of defined commands.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the number of defined commands is put in
   *         <i>size</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_NULL_POINTER_ERROR The parameter <i>size</i> is NULL.<br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The device is not opened.<br>
   *        <br>
   * @see mro_setStockCommand<br>
   * @see mro_getStockCommandMaxSize<br>
   *      Original signature :
   *      <code>MroBoolean mro_getCommandStockSize(int*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:847</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getCommandStockSize")
  public static byte mroGetCommandStockSize(Pointer<Integer> size,
                                            Pointer<Integer> status)
  {
    return mroGetCommandStockSize(Pointer.getPeer(size),
                                  Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getCommandStockSize")
  protected native static byte mroGetCommandStockSize(@Ptr long size,
                                                      @Ptr long status);

  /**
   * Indicates the stock's capacity.<br>
   * Returns the number of command that can contain the stock.<br>
   * <br>
   * 
   * @param size
   *          Pointer to the variable where to copy the command stock<br>
   *          capacity.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the capacity of the command stock is copied in
   *         <i>size</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_NULL_POINTER_ERROR The parameter <i>size</i> is NULL.<br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The device is not opened.<br>
   *        <br>
   * @see mro_getCommandStockSize<br>
   *      Original signature :
   *      <code>MroBoolean mro_getCommandStockMaxSize(int*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:871</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getCommandStockMaxSize")
  public static byte mroGetCommandStockMaxSize(Pointer<Integer> size,
                                               Pointer<Integer> status)
  {
    return mroGetCommandStockMaxSize(Pointer.getPeer(size),
                                     Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getCommandStockMaxSize")
  protected native static byte mroGetCommandStockMaxSize(@Ptr long size,
                                                         @Ptr long status);

  /**
   * Indicates if the monitoring is enabled.<br>
   * Returns whether the monitoring is enabled or not. <br>
   * <br>
   * At open, the monitoring is disabled. See mro_setMonitoringEnabled<br>
   * for monitoring enabling.<br>
   * <br>
   * 
   * @param enabled
   *          Pointer of the MroBoolean where to put the result.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the result is put in <i>enabled</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The device is not opened.<br>
   * @throw MRO_NULL_POINTER_ERROR The parameter <i>enabled</i> is NULL.<br>
   *        <br>
   * @see mro_setMonitoringEnabled<br>
   *      Original signature :
   *      <code>MroBoolean mro_isMonitoringEnabled(MroBoolean*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:902</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_isMonitoringEnabled")
  public static byte mroIsMonitoringEnabled(Pointer<Byte> enabled,
                                            Pointer<Integer> status)
  {
    return mroIsMonitoringEnabled(Pointer.getPeer(enabled),
                                  Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_isMonitoringEnabled")
  protected native static byte mroIsMonitoringEnabled(@Ptr long enabled,
                                                      @Ptr long status);

  /**
   * Enables or disables the monitoring.<br>
   * If <i>enabled</i> is true and the monitoring is disabled, the monitoring is
   * <br>
   * started. <br>
   * <br>
   * If <i>enabled</i> is false and the monitoring is enabled, the monitoring
   * is<br>
   * stopped. <br>
   * <br>
   * <br>
   * 
   * @remark Enabling the monitoring allow:<br>
   *         - the use of the functions concerning the current temperature and
   *         intensity,<br>
   *         - enables the automatic reconnection on connection loss,<br>
   *         - enables the event notifications (see mro_registerCallback),<br>
   *         - enables the detection of connection problem and system
   *         locking.<br>
   *         <br>
   * @param enabled
   *          If MRO_TRUE, the monitoring is enabled,<br>
   *          if MRO_FALSE, the monitoring is disabled.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the monitoring is successfully enabled or disabled,<br>
   *         MRO_FALSE an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_DEVICE_IO_ERROR A communication error with the mirao 52-e device
   *        occured.<br>
   * @throw MRO_OPERATING_SYSTEM_ERROR A system error occured while using an OS
   *        functionnality.<br>
   * @throw MRO_DEVICE_DRIVER_ERROR An error occured using the USB driver.<br>
   * @throw MRO_USB_INVALID_HANDLE The handle of the USB port is not more
   *        valid.<br>
   * @throw MRO_USB_DEVICE_NOT_OPENED The USB port is not opened.<br>
   * @throw MRO_USB_IO_ERROR A communication error occured on the USB
   *        device.<br>
   * @throw MRO_USB_INSUFFICIENT_RESOURCES The system resources are insufficient
   *        to perform the operation.<br>
   * @throw MRO_USB_NOT_SUPPORTED The function is not supported by the USB
   *        driver.<br>
   *        <br>
   * @see MroInfo<br>
   * @see mro_isMonitoringEnabled<br>
   * @see mro_registerCallback<br>
   *      Original signature :
   *      <code>MroBoolean mro_setMonitoringEnabled(MroBoolean, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:944</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_setMonitoringEnabled")
  public static byte mroSetMonitoringEnabled(byte enabled,
                                             Pointer<Integer> status)
  {
    return mroSetMonitoringEnabled(enabled, Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_setMonitoringEnabled")
  protected native static byte mroSetMonitoringEnabled(byte enabled,
                                                       @Ptr long status);

  /**
   * Indicates the mirror temperature.<br>
   * Returns the current mirror temperature in degree celsius (\u00b0C). <br>
   * <br>
   * The monitoring must be enabled.<br>
   * <br>
   * 
   * @remark Warning: This function always returns an error as it is not <br>
   *         implemented in this version of the mirao 52-e DLL.<br>
   *         <br>
   * @param val
   *          Pointer to the MroTemperature where to put the mirror<br>
   *          temperature.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the mirror temperature is put in <i>val</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_DEVICE_DISCONNECTED_ERROR A connection problem with the mirao
   *        mirao 52-e device has been detected.<br>
   * @throw MRO_UNAVAILABLE_DATA_ERROR The monitoring is not enabled.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>val</i> is
   *        NULL.<br>
   *        <br>
   * @see MroTemperature<br>
   * @see mro_setMonitoringEnabled<br>
   * @see mro_getMirrorLockTemperature<br>
   *      Original signature :
   *      <code>MroBoolean mro_getMirrorTemperature(MroTemperature*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:976</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getMirrorTemperature")
  public static byte mroGetMirrorTemperature(Pointer<Double> val,
                                             Pointer<Integer> status)
  {
    return mroGetMirrorTemperature(Pointer.getPeer(val),
                                   Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getMirrorTemperature")
  protected native static byte mroGetMirrorTemperature(@Ptr long val,
                                                       @Ptr long status);

  /**
   * Indicates the power supply temperature.<br>
   * Returns the current temperature of the power supply. The temperature is
   * <br>
   * indicated in degree celsuis (\u00b0C). <br>
   * <br>
   * The monitoring must be enabled.<br>
   * <br>
   * 
   * @param val
   *          Pointer to the MroTemperature where to put the power supply<br>
   *          temperature.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the power supply temperature is put in <i>val</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_DEVICE_DISCONNECTED_ERROR A connection problem with the mirao
   *        52-e device has been detected.<br>
   * @throw MRO_UNAVAILABLE_DATA_ERROR The monitoring is not enabled.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>val</i> is
   *        NULL.<br>
   *        <br>
   * @see MroTemperature<br>
   * @see mro_setMonirotingEnabled<br>
   * @see mro_getPowerSupplyLockTemperature<br>
   *      Original signature :
   *      <code>MroBoolean mro_getPowerSupplyTemperature(MroTemperature*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:1006</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getPowerSupplyTemperature")
  public static byte mroGetPowerSupplyTemperature(Pointer<Double> val,
                                                  Pointer<Integer> status)
  {
    return mroGetPowerSupplyTemperature(Pointer.getPeer(val),
                                        Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getPowerSupplyTemperature")
  protected native static byte mroGetPowerSupplyTemperature(@Ptr long val,
                                                            @Ptr long status);

  /**
   * Indicates the intensity in the negative coils.<br>
   * Returns the intensity in the negative coils of the mirao 52-e device. <br>
   * <br>
   * The intensity is returned in Amperes (A). <br>
   * <br>
   * The monitoring must be enabled.<br>
   * <br>
   * 
   * @param val
   *          Pointer of the MroIntensity where to put the intensity in<br>
   *          the negative coils.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the negative coils intensity is put in <i>val</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_DEVICE_DISCONNECTED_ERROR A connection problem with the mirao
   *        device has been detected.<br>
   * @throw MRO_UNAVAILABLE_DATA_ERROR The monitoring is not enabled.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>status</i> is
   *        NULL.<br>
   *        <br>
   * @see MroIntensity<br>
   * @see mro_setMonitoringEnabled<br>
   * @see mro_getNegativeCoilsIntensity<br>
   *      Original signature :
   *      <code>MroBoolean mro_getNegativeCoilsIntensity(MroIntensity*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:1036</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getNegativeCoilsIntensity")
  public static byte mroGetNegativeCoilsIntensity(Pointer<Double> val,
                                                  Pointer<Integer> status)
  {
    return mroGetNegativeCoilsIntensity(Pointer.getPeer(val),
                                        Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getNegativeCoilsIntensity")
  protected native static byte mroGetNegativeCoilsIntensity(@Ptr long val,
                                                            @Ptr long status);

  /**
   * Indicates the intensity in the positive coils.<br>
   * Returns the intensity in the positive coils. The intensity is returned in
   * <br>
   * Amperes (A). <br>
   * <br>
   * The monitoring must be enabled.<br>
   * <br>
   * 
   * @param val
   *          Pointer of the MroIntensity where to put the intensity in<br>
   *          the positive coils.<br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the positive coils intensity is put in <i>val</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_DEVICE_DISCONNECTED_ERROR A connection problem with the mirao
   *        52-e device has been detected.<br>
   * @throw MRO_UNAVAILABLE_DATA_ERROR The monitoring is not enabled.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>val</i> is
   *        NULL.<br>
   *        <br>
   * @see MroIntensity<br>
   * @see mro_setMonitoringEnabled<br>
   * @see mro_getPositiveCoilsLockIntensity<br>
   *      Original signature :
   *      <code>MroBoolean mro_getPositiveCoilsIntensity(MroIntensity*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:1065</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getPositiveCoilsIntensity")
  public static byte mroGetPositiveCoilsIntensity(Pointer<Double> val,
                                                  Pointer<Integer> status)
  {
    return mroGetPositiveCoilsIntensity(Pointer.getPeer(val),
                                        Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getPositiveCoilsIntensity")
  protected native static byte mroGetPositiveCoilsIntensity(@Ptr long val,
                                                            @Ptr long status);

  /**
   * Indicates the mirror lock temperature.<br>
   * Returns the temperature of the mirror over which the mirao 52-e is locked.
   * <br>
   * <br>
   * The temperature is returned in degree Celsius (\u00b0C).<br>
   * <br>
   * 
   * @remark Warning: this function always returns an error as it is not
   *         implemented in <br>
   *         this version of the mirao 52-e DLL.<br>
   *         <br>
   * @param val
   *          Pointer of the MroTemperature where to put the mirror<br>
   *          lock temperature.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the mirror lock temperature is put in <i>val</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_UNAVAILABLE_DATA_ERROR The monitoring is not enabled.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>val</i> is
   *        NULL.<br>
   *        <br>
   * @see MroTemperature<br>
   * @see mro_setMonitoringEnabled<br>
   * @see mro_getMirrorTemperature<br>
   *      Original signature :
   *      <code>MroBoolean mro_getMirrorLockTemperature(MroTemperature*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:1096</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getMirrorLockTemperature")
  public static byte mroGetMirrorLockTemperature(Pointer<Double> val,
                                                 Pointer<Integer> status)
  {
    return mroGetMirrorLockTemperature(Pointer.getPeer(val),
                                       Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getMirrorLockTemperature")
  protected native static byte mroGetMirrorLockTemperature(@Ptr long val,
                                                           @Ptr long status);

  /**
   * Indicates the power supply lock temperature.<br>
   * Returns the power supply temperature over which the mirao 52-e device is
   * locked. <br>
   * <br>
   * The temperature is returned in degree Celsius (\u00b0C).<br>
   * <br>
   * 
   * @param val
   *          Pointer of the MroTemperature where to put the power supply<br>
   *          lock temperature.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the power supply lock temperature is put in
   *         <i>val</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>val</i> is
   *        NULL.<br>
   *        <br>
   * @see MroTemperature<br>
   * @see mro_setMonitoringEnabled<br>
   * @see mro_getPowerSupplyTemperature<br>
   *      Original signature :
   *      <code>MroBoolean mro_getPowerSupplyLockTemperature(MroTemperature*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:1123</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getPowerSupplyLockTemperature")
  public static byte mroGetPowerSupplyLockTemperature(Pointer<Double> val,
                                                      Pointer<Integer> status)
  {
    return mroGetPowerSupplyLockTemperature(Pointer.getPeer(val),
                                            Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getPowerSupplyLockTemperature")
  protected native static byte mroGetPowerSupplyLockTemperature(@Ptr long val,
                                                                @Ptr long status);

  /**
   * Indicates the negative coils lock intensity.<br>
   * Returns the intensity in the negative coils over which mirao 52-e device is
   * locked.<br>
   * <br>
   * The intensity is returned in Amperes (A).<br>
   * <br>
   * 
   * @param val
   *          Pointer of the MroIntensity where to put the negative coils<br>
   *          lock intensity.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the negative coils lock intensity is put in
   *         <i>val</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>val</i> is
   *        NULL.<br>
   *        <br>
   * @see MroIntensity<br>
   * @see mro_setMonitoringEnabled<br>
   * @see mro_getNegativeCoilsIntensity<br>
   *      Original signature :
   *      <code>MroBoolean mro_getNegativeCoilsLockIntensity(MroIntensity*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:1150</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getNegativeCoilsLockIntensity")
  public static byte mroGetNegativeCoilsLockIntensity(Pointer<Double> val,
                                                      Pointer<Integer> status)
  {
    return mroGetNegativeCoilsLockIntensity(Pointer.getPeer(val),
                                            Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getNegativeCoilsLockIntensity")
  protected native static byte mroGetNegativeCoilsLockIntensity(@Ptr long val,
                                                                @Ptr long status);

  /**
   * Indicates the positive coils lock intensity.<br>
   * Returns the intensity in the positive coils over which the mirao 52-e
   * device is locked. <br>
   * <br>
   * The intensity is returned in Amperes (A).<br>
   * <br>
   * 
   * @param val
   *          Pointer of the MroIntensity where to put the positive coils<br>
   *          lock intensity.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the positive coils lock intensity is put in
   *         <i>val</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>val</i> is
   *        NULL.<br>
   *        <br>
   * @see MroIntensity<br>
   * @see mro_setMonitoringEnabled<br>
   * @see mro_getPositiveCoilsIntensity<br>
   *      Original signature :
   *      <code>MroBoolean mro_getPositiveCoilsLockIntensity(MroIntensity*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:1177</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_getPositiveCoilsLockIntensity")
  public static byte mroGetPositiveCoilsLockIntensity(Pointer<Double> val,
                                                      Pointer<Integer> status)
  {
    return mroGetPositiveCoilsLockIntensity(Pointer.getPeer(val),
                                            Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_getPositiveCoilsLockIntensity")
  protected native static byte mroGetPositiveCoilsLockIntensity(@Ptr long val,
                                                                @Ptr long status);

  /**
   * Indicates if the device is locked.<br>
   * Returns whether the mirao 52-e device is locked or not. <br>
   * <br>
   * The monitoring must be enabled.<br>
   * <br>
   * 
   * @param val
   *          Pointer to the MroBoolean where to put the result.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the result is put in <i>val</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_UNAVAILABLE_DATA_ERROR The monitoring is not enabled.<br>
   * @throw MRO_DEVICE_DISCONNECTED_ERROR A connection problem with the mirao
   *        52-e device has been detected.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>val</i> is
   *        NULL.<br>
   *        <br>
   * @see mro_setMonitoringEnabled<br>
   * @see mro_getMirrorLockTemperature<br>
   * @see mro_getPowerSupplyLockTemperature<br>
   * @see mro_getPositiveCoilsLockIntensity<br>
   * @see mro_getNegativeCoilsLockIntensity<br>
   *      Original signature :
   *      <code>MroBoolean mro_isLocked(MroBoolean*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:1207</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_isLocked")
  public static byte mroIsLocked(Pointer<Byte> val,
                                 Pointer<Integer> status)
  {
    return mroIsLocked(Pointer.getPeer(val), Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_isLocked")
  protected native static byte mroIsLocked(@Ptr long val,
                                           @Ptr long status);

  /**
   * Indicates if the mirao 52-e is connected.<br>
   * Returns False if a connection problem has been detected. <br>
   * <br>
   * The monitoring must be enabled.<br>
   * <br>
   * 
   * @param val
   *          Pointer to the MroBoolean where to put the result.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the result is put in <i>val</i>,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_UNAVAILABLE_DATA_ERROR The monitoring is not enabled.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>val</i> is
   *        NULL.<br>
   *        <br>
   * @see mro_setMonitoringEnabled<br>
   *      Original signature :
   *      <code>MroBoolean mro_isConnected(MroBoolean*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:1231</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_isConnected")
  public static byte mroIsConnected(Pointer<Byte> val,
                                    Pointer<Integer> status)
  {
    return mroIsConnected(Pointer.getPeer(val),
                          Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_isConnected")
  protected native static byte mroIsConnected(@Ptr long val,
                                              @Ptr long status);

  /**
   * Registers a function to call in case of event arrival.<br>
   * The callback function pointed by <i>callback</i> will be notified of
   * the<br>
   * events concerning the mirao 52-e device. <br>
   * <br>
   * The notifications concern:<br>
   * - transmission errors, <br>
   * - connection lost and recoverd,<br>
   * - mirao lock entrance and exit,<br>
   * - and monitoring start and stop<br>
   * .<br>
   * The <i>callback</i> function must respect this signature: <br>
   * <br>
   * - <code>void callbackFunctionName( MiraoInfo* miraoInfo );</code><br>
   * .<br>
   * To be notified of these events (except for monitoring starting and
   * stopping),<br>
   * the monitoring must be enabled.<br>
   * <br>
   * 
   * @param callback
   *          Pointer to the callback function.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the callback is successfully registred,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>callback</i> is
   *        NULL.<br>
   *        <br>
   * @see mro_setMonitoringEnabled<br>
   *      Original signature :
   *      <code>MroBoolean mro_registerCallback(MroRegisterCallbackCallbackCallback*, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:1265</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_registerCallback")
  public static byte mroRegisterCallback(Pointer<Mirao52eLibrary.MroRegisterCallbackCallbackCallback> callback,
                                         Pointer<Integer> status)
  {
    return mroRegisterCallback(Pointer.getPeer(callback),
                               Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_registerCallback")
  protected native static byte mroRegisterCallback(@Ptr long callback,
                                                   @Ptr long status);

  /**
   * Unregisters the function to call in case of event arrival.<br>
   * The callback function registered with <i>mro_registerCallback</i> is <br>
   * unregistered. It is not notificated of events about the mirao 52-e
   * device<br>
   * anymore. <br>
   * <br>
   * If no callback function is registered, nothing happen.<br>
   * <br>
   * 
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the callback is successfully unregistred,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The device is not opened.<br>
   *        <br>
   * @see mro_registerCallback<br>
   *      Original signature :
   *      <code>MroBoolean mro_unregisterCallback(int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:1288</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_unregisterCallback")
  public static byte mroUnregisterCallback(Pointer<Integer> status)
  {
    return mroUnregisterCallback(Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_unregisterCallback")
  protected native static byte mroUnregisterCallback(@Ptr long status);

  /**
   * Saves a command to a file.<br>
   * The set of values contained in <i>command</i> is written into the file<br>
   * specified by <i>filePath</i>. <br>
   * <br>
   * The output file has the MRO format version MRO.001.001.20080609. Its
   * name<br>
   * must end with the extension <code>.mro</code> .<br>
   * <br>
   * 
   * @param command
   *          Command to save.<br>
   *          <br>
   * @param filaPath
   *          Null terminated character string containing the path of<br>
   *          the file to create.<br>
   *          <br>
   * @param overwrite
   *          If MRO_TRUE, if the file already exists it is overwritten,<br>
   *          if MRO_FALSE, if the file already exists an error is<br>
   *          raised.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the command is successfully saved into the specified
   *         file,<br>
   *         MRO_TRUE if an error occurs.<br>
   *         <br>
   * @throw MRO_DEVICE_NOT_OPENED_ERROR The mirao 52-e device is not opened.<br>
   * @throw MRO_INVALID_COMMAND_ERROR The set of values contained in
   *        <i>command</i> is invalid.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>filePath</i> is
   *        NULL.<br>
   * @throw MRO_FILE_EXISTS_ERROR The file specified by <i>filePath</i> already
   *        exists and the parameter <i>overwrite</i> is set to MRO_FALSE.<br>
   * @throw MRO_OUT_OF_SPECIFICATIONS_ERROR The value of the parameter
   *        <i>filePath</i> is out of specifications. It must be a file name
   *        ending by .mro.<br>
   * @throw MRO_FILE_IO_ERROR An error occured while writing the file.<br>
   * @throw MRO_FILE_IO_EACCES Permission on the file denied.<br>
   * @throw MRO_FILE_IO_EAGAIN No more free processes.<br>
   * @throw MRO_FILE_IO_EBADF Bad file descriptor.<br>
   * @throw MRO_FILE_IO_EINVAL Invalid argument passed to the write
   *        function.<br>
   * @throw MRO_FILE_IO_EMFILE Too many open files.<br>
   * @throw MRO_FILE_IO_ENOENT No such file or directory.<br>
   * @throw MRO_FILE_IO_ENOMEM Not enough memory in the system.<br>
   * @throw MRO_FILE_IO_ENOSPC No more sapce available on the device.<br>
   *        <br>
   * @see MroCommand<br>
   * @see mro_readCommandFile<br>
   *      Original signature :
   *      <code>MroBoolean mro_writeCommandFile(MroCommand, char*, MroBoolean, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:1339</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_writeCommandFile")
  public static byte mroWriteCommandFile(Pointer<Double> command,
                                         Pointer<Byte> filePath,
                                         byte overwrite,
                                         Pointer<Integer> status)
  {
    return mroWriteCommandFile(Pointer.getPeer(command),
                               Pointer.getPeer(filePath),
                               overwrite,
                               Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_writeCommandFile")
  protected native static byte mroWriteCommandFile(@Ptr long command,
                                                   @Ptr long filePath,
                                                   byte overwrite,
                                                   @Ptr long status);

  /**
   * Reads a command from a file.<br>
   * The set of values contained in the file specified by <i>filePath</i> is<br>
   * stored into <i>command</i>. <br>
   * <br>
   * The file must be a valid MRO.001.001.20080609 file with the extension <br>
   * <code>.mro</code>.<br>
   * <br>
   * 
   * @param filePath
   *          Null terminated character string containing the path of<br>
   *          the file to create.<br>
   *          <br>
   * @param command
   *          Array into which to put the command read.<br>
   *          <br>
   * @param status
   *          Pointer to an integer containing the error code if an error<br>
   *          occurs or MRO_OK if the call returns successfully.<br>
   *          <br>
   * @return MRO_TRUE if the command is successfully read,<br>
   *         MRO_FALSE if an error occurs.<br>
   *         <br>
   * @throw MRO_INVALID_COMMAND_ERROR The set of values contained in
   *        <i>command</i> is invalid.<br>
   * @throw MRO_NULL_POINTER_ERROR The value of the parameter <i>filePath</i> or
   *        <i>command</i> is NULL.<br>
   * @throw MRO_OUT_OF_SPECIFICATIONS_ERROR The value of the parameter
   *        <i>filePath</i> is out of specifications. It must be a filename
   *        ending by .mro.<br>
   * @throw MRO_FILE_FORMAT_ERROR The file specified by <i>filePath</i> has not
   *        a valid MRO file format.<br>
   * @throw MRO_FILE_FORMAT_VERSION_ERROR The version of the MRO file format is
   *        not supported.<br>
   * @throw MRO_FILE_IO_ERROR An error occurd while reading the file.<br>
   * @throw MRO_FILE_IO_EACCES Permission denied on the file.<br>
   * @throw MRO_FILE_IO_EAGAIN No more free processes.<br>
   * @throw MRO_FILE_IO_EBADF Bad file descriptor.<br>
   * @throw MRO_FILE_IO_EINVAL Invalid argument passed to the read function.<br>
   * @throw MRO_FILE_IO_EMFILE Too many open files.<br>
   * @throw MRO_FILE_IO_ENOENT No such file or directory.<br>
   * @throw MRO_FILE_IO_ENOMEM Not enough free memory in the system.<br>
   * @throw MRO_FILE_IO_ENOSPC No more space available on the device.<br>
   *        <br>
   * @see MroCommand<br>
   * @see mro_writeCommandFile<br>
   *      Original signature :
   *      <code>MroBoolean mro_readCommandFile(char*, MroCommand, int*)</code><br>
   *      <i>native declaration : lib\mirao52e\mirao52e.h:1383</i>
   */
  @Convention(Convention.Style.StdCall)
  @Name("mro_readCommandFile")
  public static byte mroReadCommandFile(Pointer<Byte> filePath,
                                        Pointer<Double> command,
                                        Pointer<Integer> status)
  {
    return mroReadCommandFile(Pointer.getPeer(filePath),
                              Pointer.getPeer(command),
                              Pointer.getPeer(status));
  }

  @Convention(Convention.Style.StdCall)
  @Name("mro_readCommandFile")
  protected native static byte mroReadCommandFile(@Ptr long filePath,
                                                  @Ptr long command,
                                                  @Ptr long status);
}
